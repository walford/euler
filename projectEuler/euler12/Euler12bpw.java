// The sequence of triangle numbers is generated by adding the natural numbers. 
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first 

// ten terms would be:
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

// Let us list the factors of the first seven triangle numbers:
//  1: 1
//  3: 1,3
//  6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.
// What is the value of the first triangle number to have over five hundred divisors?


import static java.lang.System.out;
import java.util.*;

public class Euler12bpw {

	public static void main(String[] argv) {

		int answer = 0;

		int count = 0;
		int triangle = 0;
		int divisors = 0;

		while(divisors <= 500) {

			divisors = 0;
			count++;
			triangle += count;

			ArrayList<Integer> init_list = new ArrayList<Integer>();
			ArrayList<Integer> pFacs = get_prime_factors(init_list, triangle);

			divisors = num_factors(pFacs);
			answer = triangle;

		}

		out.println(answer);		

	}

	static ArrayList<Integer> get_prime_factors(ArrayList<Integer> list, int num) {

        ArrayList<Integer> growing_list = new ArrayList<Integer>();
        growing_list = list;

        if(is_prime(num) == true) {
            growing_list.add(num);
        } else if(is_prime(num) == false) {
            for(int i=2; i<=num; i++) {
                if((is_prime(i) == true) && (num % i == 0)) {
                    growing_list.add(i);
                    get_prime_factors(growing_list, num/i);
                    break;
                }
            }
        }
        return growing_list;
    }

    static int num_factors(ArrayList<Integer> list) {

        int divisors = 1;
        int count = 0; 

        int last_i = 0;
        for(Integer i : list) {
            count = 1;
            
            if(list.indexOf(i) == list.indexOf(last_i)) {
                continue;
            }
            last_i = i;
            
            for (Integer j : list) {
                if(i == j) {
                    count += 1;
                }
            }
            divisors *= count;
        }

        return divisors;
    }

    static boolean is_prime(int num) {
        for(int i=2; i<=Math.sqrt(num); i++) {
            if(num % i == 0) {
                return false;
            }
        }
        return true;
    }


}


// need to check if num is prime, if so, it is added to the list and the list is complete, then break
// if num isn't prime, loop until first prime divisor is found
// then add new found divisor to list
// then num equal num divided my new found divisor
// last, recall the function with new num







